name: Create Issue Comment
description: Create or updste an issue comment
inputs:
  comment:
    description: Comment Text
    required: true
  comment_path:
    description: "Path to txt file to be parsed"
    required: false
  comment_id:
    description: "Unique identifier for deduplicating comments"
    default: "Create Issue Action"
    required: false
  issue_number:
    description: Local Pull Request/Issue number to work on
    required: true
  gh_token:
    description: gh api access token to use
    required: true
  repository:
    description: the OWNER/REPOSITORY to operate on
    required: true

runs:
  using: "composite"
  steps:
    - name: Generate Comment Text
      shell: bash
      env:
        COMMENT_ID: ${{ inputs.comment_id }}
        COMMENT_TEXT: ${{ inputs.comment }}
        COMMENT_FILE: ${{ inputs.comment_path }}
      run: |
        comment_body="<!--(ID:${COMMENT_ID})-->${COMMENT_TEXT}"
        if [ -f "$COMMENT_FILE" ] ; then
          echo "Reading comment file from ${COMMENT_FILE}"
          comment_body="${comment_body}$(cat "$COMMENT_FILE")"
        fi
        echo "COMMENT_BODY=$comment_body" >> "$GITHUB_ENV"

    - name: Get Existing Comment Id
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh_token }}
        ISSUE_NUMBER: ${{ inputs.issue_number }}
        REPOSITORY: ${{ inputs.repository }}
        COMMENT_ID: ${{ inputs.comment_id }}
      run: |
        owner=$(echo "$REPOSITORY" | cut -d '/' -f 1)
        repo=$(echo "$REPOSITORY" | cut -d '/' -f 2)
        data=$(
          gh api graphql \
            --paginate \
            -f owner="$owner" \
            -f repo="$repo" \
            -F issue="$ISSUE_NUMBER" \
            -f query='
              query($repo: String!, $owner: String!, $issue: Int!, $endCursor: String) {
                repository(name: $repo, owner: $owner) {
                  issueOrPullRequest(number: $issue) {
                    ... on Issue {
                      id
                      number
                      comments(first: 100, after: $endCursor) {
                        nodes {
                          id
                          body
                        }
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                      }
                    }
                    ... on PullRequest {
                      id
                      number
                      comments(first: 100, after: $endCursor) {
                        nodes {
                          id
                          body
                        }
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                      }
                    }
                  }
                }
              }
              ' \
              --jq '' | jq -c --arg comment_id "<!--(ID:$COMMENT_ID)-->" '
            .[0].data.repository.issueOrPullRequest.id as $id |
            [ .[].data.repository.issueOrPullRequest.comments.nodes[] ] as $data | 
            [ $data.[] | select(.body | startswith($comment_id)) ] as $id_comments |
            if ($id_comments | length) > 0 then
               { "issueId": $id, "commentId": $id_comments[0].id }
            else
               { "issueId": $id, "commentId": "" }
            end
          '
        )
        echo "ISSUE_NODE_ID=$(jq -r '.issueId' <<< "$data")" >> "$GITHUB_ENV"
        echo "COMMENT_NODE_ID=$(jq -r '.commentId' <<< "$data")" >> "$GITHUB_ENV"

    - name: Edit Existing Comment
      if: env.COMMENT_NODE_ID != ''
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh_token }}
      run: |
        gh api graphql \
          -f comment_id="$COMMENT_NODE_ID" \
          -f comment_body="$COMMENT_BODY" \
          -f query='
            mutation($comment_id: ID!, $comment_body: String!) {
              updateIssueComment(input: {
                id: $comment_id,
                body: $comment_body,
              }) {
                issueComment {
                  lastEditedAt
                }
              }
            }
          '

    - name: Create Comment
      if: env.COMMENT_NODE_ID == ''
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh_token }}
      run: |
        gh api graphql \
          -f issue_id="$ISSUE_NODE_ID" \
          -f comment_body="$COMMENT_BODY" \
          -f query='
            mutation ($issue_id: ID!, $comment_body: String!) {
              addComment(input: { subjectId: $issue_id, body: $comment_body }) {
                commentEdge {
                  node {
                    id
                  }
                }
              }
            }
          '
          


    
